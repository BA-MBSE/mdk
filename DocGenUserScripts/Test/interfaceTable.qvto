import lib.ProfileLib;
import lib.CoreLibMD;
import lib.UMLLib;
import lib.GraphAlgorithmLibraryD;
import gov.nasa.jpl.magicdraw.qvto.units.MDStereotypesHelper;
import gov.nasa.jpl.magicdraw.qvto.units.MDModelHelper;

//@efosse
//for MCR

//Columns:	Total Existing|2020 Free Instrument|2020 Free SSS|Total Free for 2020
//Rows:	Power switches(by current)_MSIA ports Telemetry channels_MCA ports
//open is attached to SSS or instrument;
//Power switches: Only the RPAM LCC switches have the size/rating filled in – so any switch interface on the RLCCs should have those (and if they don’t yes, it should be a validation error). I’ll have to add the CPAM and DPAM switches to the “total” stats by hand afterwards for now (unless a miracle happens and I get the CPAM and DPAM switches broken out before the MCR).
//MSIA ports: We are only concerned with the LVDS and RS422 ports on the MSIA cards (all 4). For the query, you could probably do just the output or input – doing both will be double booking. And then showing just the “open” ones would be the final answer we want – the INST-1,2,3 interfaces should have connections complete so any open LVDS and RS422 ports are really open.
//Analogs: Query for all open Analog:Voltage and Analog:Temp for the xREUs, xTMCs, and BCBs (RREU-A, RTMC-B, BCB-1 etc.). You can do the CPAM and DPAM ones as well and there should be no open ones since I only have generic interfaces that are tied to at least one thing. So there should only be some rover analogs that are open. 
 
//Target is MSM Package

modeltype uml uses 'http://www.nomagic.com/magicdraw/UML/2.4.1';
modeltype dgview uses 'http://mbee.jpl.nasa.gov/docgen/dgview';


transformation interfaceTable(in selectedElements:uml, out docgenOutput:dgview) {
//properties from viewpoint
	property msmPackage : uml::Package = selectedElements.rootObjects()![uml::Package];
	property flowDirection : uml::Property = null;
	property flowS : uml::Stereotype=null;
	
//Global Variables	
	property switchSter : uml::Stereotype = null;
	property logicSter : uml::Stereotype =null;
	property refDesSter : uml::Stereotype = null;
	property projectionSter: uml::Stereotype = null;
	property sizeRatingProp : uml::Property = null;
	property rs : uml::Stereotype = null;
	property tempSter:uml::Stereotype = null;
	property voltSter:uml::Stereotype = null;
	property analogSter:uml::Stereotype = null;
	property lvds : uml::Stereotype = null;
	property actuator : uml::Stereotype = null;
	property allLogical : Set(uml::Class) =Set{};
	property allRefDes : Set(uml::Class) =Set{};
	property rvrInt : uml::Class  = null;
	property genericInst : uml::Class = null;
	property instOne:uml::Class = null;
	property instTwo:uml::Class=null;
	property instThree:uml::Class=null;
	property scs:uml::Class=null;
	property allConnections:Set(uml::Connector)=null;
	property allConnectorPorts:Set(uml::Port)=null;
// helper functions are special functions in QVT not intended to return results or make new model elements.
	helper SysMLProfileSetup() {
		var sysmlPS := getProfileStereotypesByName('SysML');
		flowS := sysmlPS.getStereotypeByName('FlowProperty');
		flowDirection := flowS.ownedElement[uml::Property]->selectOne(i|i.name = "direction");
		return;
	}
	helper MarsProfileSetup(){
	//finds MSM Extensions profile and sterotypes
		var marsSter:=getProfileStereotypesByName('MSM Extensions');  
		switchSter:= marsSter.getStereotypeByName('Switch Interface');
		projectionSter := marsSter.getStereotypeByName('Interaction Projection');
		refDesSter:= marsSter.getStereotypeByName('Reference Designator');
		logicSter:=marsSter.getStereotypeByName('Logical');
		rs:=marsSter.getStereotypeByName('RS422 Data Interface');
		tempSter:=marsSter.getStereotypeByName('Temperature Interface');
		voltSter:=marsSter.getStereotypeByName('Voltage Interface');
		analogSter:=marsSter.getStereotypeByName('Analog Interface');
		lvds:=marsSter.getStereotypeByName('LVDS Data Interface');
		actuator:=marsSter.getStereotypeByName('Motor Driver');
		sizeRatingProp := marsSter.getStereotypeByName('Power Interface').ownedElement[uml::Property]->selectOne(i|i.name = 'Size/Rating');
	return;	
	}
	
//Config Properties
	configuration property VALIDATE : Boolean;
//metrics
	property switchNoRating :Integer = 0;
	
	main(){
	//add option for scope: rover, cruise, descent or combination	
		SysMLProfileSetup();
		MarsProfileSetup();
		var allEls:=msmPackage![uml::Element]->closure(ownedElement);
		allLogical:= allEls[uml::Class]->select(x| isStereotypeOrDerivedApplied(x, logicSter));
		allRefDes:= allEls[uml::Class]->select(x| isStereotypeOrDerivedApplied(x, refDesSter));
		allConnections:=allEls[uml::Connector]->select(x| isStereotypeOrDerivedApplied(x, projectionSter)=false);
		allConnections->forEach(a){
			a.ownedElement[uml::ConnectorEnd]->forEach(e){
				allConnectorPorts+=e.role![uml::Port];
			};
		};
		rvrInt:=allRefDes->selectOne(x|x.name="RVRINT");
		genericInst:=allRefDes->selectOne(x|x.name="_genInst");
		instOne:=allRefDes->selectOne(x|x.name="INST-1");
		instTwo:=allRefDes->selectOne(x|x.name="INST-2");
		instThree:=allRefDes->selectOne(x|x.name="INST-3");
		scs:=allRefDes->selectOne(x|x.name="SCS");		
		var lccLogic:=allLogical->selectOne(x|x.name="LCC");
		var reuLogic:=allLogical->selectOne(x|x.name="REU");
		var tmcLogic:=allLogical->selectOne(x|x.name="TMC");
		var rvrIntLcc:Set(uml::Class):=Set{};
		var rvrAnalog:Set(uml::Class):=Set{};
		var gens:=msmPackage![uml::Element]->closure(ownedElement)[uml::Generalization];
		gens->select(x|x.general=lccLogic)->forEach(s){
			if(rvrInt[uml::NamedElement]->asOrderedSet()->runBFS('Part Property Tree', s.specific).sortedPairs->element->select(x|x=s.specific)->size()!=0) then rvrIntLcc+=s.specific![uml::Class] endif;	
		};
		//gens->select(x|x.general=reuLogic)->forEach(s){
		//	log(s.specific![uml::NamedElement].name);
		//	if(rvrInt[uml::NamedElement]->asOrderedSet()->runBFS('Part Proprety Tree', s.specific).sortedPairs->element->select(x|x=s.specific)->size()!=0) then rvrAnalog+=s.specific![uml::Class] endif;
		//};
		//log(rvrAnalog->size().toString());
		gens->select(x|x.general=tmcLogic)->forEach(s){
			if(rvrInt[uml::NamedElement]->asOrderedSet()->runBFS('Part Property Tree', s.specific).sortedPairs->element->select(x|x=s.specific)->size()!=0)then rvrAnalog+=s.specific![uml::Class] endif;
		};
		//log(rvrAnalog->size().toString());
		//Totals
		var switchesTotal:=getPowerSwitches(rvrIntLcc);
		var msiaPortsTotal:=getMSIAPorts();
		var analogPortsTotal:=getAnalogPorts(rvrAnalog);
		var actPortsTotal:=getActuatorPorts();
		//Taken
		var switchesTaken:= findConnectedPorts(switchesTotal);
		var switchesOpen:=findOpenPorts(switchesTotal);
		var switchesOpenOut = 0;
		switchesOpen->forEach(s){
			if(s.type.ownedElement[uml::Property]->selectOne(x|isStereotypeOrDerivedApplied(x, flowS)).retrieveFlowProp('out')=true)then switchesOpenOut:=switchesOpenOut + 1 endif;
			//log(s.name);
		};
		//log(switchesOpenOut.toString());
		var msiaPortsTaken:= findConnectedPorts(msiaPortsTotal);
		var analogPortsTaken:=findConnectedPorts(analogPortsTotal);
		var actPortsTaken:=findConnectedPorts(actPortsTotal);
		var analogOpen:=findOpenPorts(analogPortsTotal);
	//	analogOpen->select(x|x.owner = allRefDes->selectOne(j|j.name="RREU-B"))->forEach(op){
		//	log(op.name);
	//	};
		var actuatorOpen:=findOpenPorts(actPortsTotal);
		log(actuatorOpen->size().toString());
		var actuatorOpenOut = 0;
		actuatorOpen->forEach(a){
			if(a.type.ownedElement[uml::Property]->selectOne(x|isStereotypeOrDerivedApplied(x, flowS)).retrieveFlowProp('out')=true)then actuatorOpenOut:=actuatorOpenOut + 1 endif;
			//log(a.name);
		};
		log(actuatorOpenOut.toString());
		
		
		var switchesIns:= findConnectedtoInstrument(switchesTaken);
		
		//log('####################');
		var msiaPortsIns:= findConnectedtoInstrument(msiaPortsTaken);
	//	log('####################');
		var analogPortsIns:=findConnectedtoInstrument(analogPortsTaken);
		analogPortsIns:=analogPortsIns-1;
	//	log('####################');
		var actPortsIns:=findConnectedtoInstrument(actPortsTaken);
	//	log('####################');
		var switchesAss:=findConnectedtoSCS(switchesTaken);
	//	log('####################');
		var msiaAss:=findConnectedtoSCS(msiaPortsTaken);
	//	log('####################');
		var analogAss:=findConnectedtoSCS(analogPortsTaken);
	//	log('####################');
		var actAss:=findConnectedtoSCS(actPortsTaken);

		map interfaceTable(switchesTotal, msiaPortsTotal, analogPortsTotal, actPortsTotal, switchesTaken, msiaPortsTaken, analogPortsTaken, actPortsTaken, 
			switchesIns, msiaPortsIns, analogPortsIns, actPortsIns, switchesAss, msiaAss, analogAss, actAss);
	}
	
	mapping interfaceTable(in switches:Set(uml::Port), in msiaPorts:Set(uml::Port), in analogPorts:Set(uml::Port), in actPorts:Set(uml::Port),
		switchesTaken:Set(uml::Port), msiaTaken:Set(uml::Port), analogTaken:Set(uml::Port), actPortsTaken:Set(uml::Port),
		switchesIns:Integer, msiaPortsIns:Integer, analogPortsIns:Integer, actPortsIns:Integer, 
		switchesAss:Integer, msiaAss:Integer, analogAss:Integer, actAss:Integer):dgview::Table@docgenOutput{
		
		
		var switchestakenNotFake:= switchesTaken->size()-switchesIns-switchesAss;
		var totalFreeSwitches:=switches->size()-switchestakenNotFake;
		var spareSwitch:=switches->size()-switchesTaken->size();
		
		var analogtakenNotFake := analogTaken->size()-analogPortsIns-analogAss+2;
		var totalFreeAnalog:=analogPorts->size()-analogtakenNotFake;
		var spareAnalog:=analogPorts->size()-analogTaken->size()-2;
		var analogTestTaken := analogTaken->size()+2;
		
		var msiaTakenNotFake:= msiaTaken->size()-msiaPortsIns-msiaAss;
		var totalFreemsia:=msiaPorts->size()-msiaTakenNotFake;
		var spareMSIA:=msiaPorts->size()-msiaTaken->size();
		
		var actTakenNotFake:=actPortsTaken->size()-actPortsIns-actAss;
		var totalFreeAct:=actPorts->size()-actTakenNotFake;
		var spareAct:=actPorts->size()-actPortsTaken->size();
		
		var switches:=Sequence{object dgview::Text{text:='RPAM Power Switches';}, object dgview::Text{text:=switches->size().toString();}, 
			object dgview::Text{text:='164';}, object dgview::Text{text:='4';},object dgview::Text{text:='38';}, object dgview::Text{text:='54';},
			object dgview::Text{text:=totalFreeSwitches.toString();}, object dgview::Text{text:=switchesIns.toString();}, object dgview::Text{text:=switchesAss.toString();}, object dgview::Text{text:=switchesTaken->size().toString();}, object dgview::Text{text:=spareSwitch.toString();}};
		
		var analog:=Sequence{object dgview::Text{text:='RVR Analogs';}, object dgview::Text{text:=analogPorts->size().toString();}, 
			object dgview::Text{text:='299';}, object dgview::Text{text:='113';}, object dgview::Text{text:='52';}, object dgview::Text{text:='36';},  
			object dgview::Text{text:=totalFreeAnalog.toString();}, object dgview::Text{text:=analogPortsIns.toString();}, object dgview::Text{text:=analogAss.toString();}, object dgview::Text{text:=analogTestTaken.toString();}, object dgview::Text{text:=spareAnalog.toString();}};
		
		var msia:=Sequence{object dgview::Text{text:='MSIA Ports';}, object dgview::Text{text:=msiaPorts->size().toString();}, 
			object dgview::Text{text:='22';}, object dgview::Text{text:='2';}, object dgview::Text{text:='0';}, object dgview::Text{text:='22';}, 
			object dgview::Text{text:=totalFreemsia.toString();}, object dgview::Text{text:=msiaPortsIns.toString();}, object dgview::Text{text:=msiaAss.toString();}, object dgview::Text{text:=msiaTaken->size().toString();}, object dgview::Text{text:=spareMSIA.toString();}};
		
		var actuator:=Sequence{object dgview::Text{text:='RMCA Actuators';}, object dgview::Text{text:=actPorts->size().toString();}, 
			object dgview::Text{text:='43';}, object dgview::Text{text:='10';}, object dgview::Text{text:='28';}, object dgview::Text{text:='0';}, 
			object dgview::Text{text:=totalFreeAct.toString();}, object dgview::Text{text:=actPortsIns.toString();}, object dgview::Text{text:=actAss.toString();}, object dgview::Text{text:=actPortsTaken->size().toString();}, object dgview::Text{text:=spareAct.toString();}};
			

		result.body:=Sequence{object dgview::TableRow{children:=switches}, object dgview::TableRow{children:=analog}, object dgview::TableRow{children:=msia}, object dgview::TableRow{children:=actuator}};
		result.headers:=Sequence{object dgview::TableRow{children:=Sequence{object dgview::Text{text := ' ';}, object dgview::Text{text:='Total Existing';}, object dgview::Text{text:='MSL Total Used';}, object dgview::Text{text:='MSL Spare';}, object dgview::Text{text:='MSL SSS Use';},
			 object dgview::Text{text:='MSL Inst Use';}, object dgview::Text{text:='M2020 Total Available';}, object dgview::Text{text:='M2020 Inst Used Predict';}, object dgview::Text{text:='M2020 SCS Used Predict';}, 
			object dgview::Text{text:='M2020 Total Used Predict';},object dgview::Text{text:='M2020 Spare';}}}};
		result.title:='Interface Metrics';
	}
	query findConnectedPorts(in ports:Set(uml::Port)):Set(uml::Port){
		var connectedPorts:Set(uml::Port)=Set{};
		connectedPorts:=ports->select(x|x._end->size()>0);
		return connectedPorts;
	}
	
	query findOpenPorts(in ports:Set(uml::Port)):Set(uml::Port){
		var openPort:Set(uml::Port)=Set{};
		ports->forEach(p){
			//log(p._end->size().toString());
			if(p._end->size()=0)then openPort+=p endif;
		};
		return openPort;
	}
	
	query findConnectedtoInstrument(in ports:Set(uml::Port)):Integer{
		var portConnections:Set(uml::Connector):=Set{};
		var instrumentPorts:Integer = 0;
		ports->forEach(p){
			allConnections->forEach(c){
				var cEnds:= c.ownedElement[uml::ConnectorEnd];
				cEnds->forEach(x){
					if(x.role![uml::Port] = p)then{
						portConnections+=c;
					}endif;
				};
			};
		};
		portConnections->forEach(c){
			var cEnds:= c.ownedElement[uml::ConnectorEnd];
			cEnds->forEach(e){
				var ePort:=e![uml::ConnectorEnd].role![uml::Port];
				if(ePort.owner=genericInst)then {
					instrumentPorts:=instrumentPorts+1;
					//log(c.name);
					//log(cEnds->select(x|x!=e)![uml::ConnectorEnd].role![uml::Port].name);
				}endif;
				if(ePort.owner=instOne) then {
					instrumentPorts:=instrumentPorts+1;
					//log(c.name);
					//log(cEnds->select(x|x!=e)![uml::ConnectorEnd].role![uml::Port].name);
				}endif;
				if(ePort.owner=instTwo) then {
					instrumentPorts:=instrumentPorts+1; 
					//log(c.name);
					//log(cEnds->select(x|x!=e)![uml::ConnectorEnd].role![uml::Port].name);
				}endif;
				if(ePort.owner=instThree) then {
					instrumentPorts:=instrumentPorts+1; 
					//log(c.name);
					//log(cEnds->select(x|x!=e)![uml::ConnectorEnd].role![uml::Port].name);
				}endif;
			};
		};
		return instrumentPorts;
	}
	
	query findConnectedtoSCS(in ports:Set(uml::Port)):Integer{
		var portConnections:Set(uml::Connector):=Set{};
		var scsPorts:Integer=0;
		ports->forEach(p){
			allConnections->forEach(c){
				var cEnds:= c.ownedElement[uml::ConnectorEnd];
				cEnds->forEach(x){
					if(x.role![uml::Port] = p)then{
						portConnections+=c;
					}endif;
				};
			};
		};
		portConnections->forEach(c){
			var cEnds:= c.ownedElement[uml::ConnectorEnd];
			cEnds->forEach(e){
				var ePort:=e![uml::ConnectorEnd].role![uml::Port];
				if(ePort.owner=scs)then {
					scsPorts:=scsPorts+1;
				//	log(cEnds->select(x|x!=e)![uml::ConnectorEnd].role![uml::Port].name);
				}endif;
			};
		};
		return scsPorts;
	}
	query getPowerSwitches(in lcc:Set(uml::Class)):Set(uml::Port){
	//Power switches: 
	//[validation]:all power switches on the RLCC should have size/rating filled in
	//[categories]:size rating options: 10A, 4A, 2A*not yet*
	//[filter]filter: generalize from LCC and has ownership of rover internal
	//RLCC only(port owned directly by RLCC)
		var rightSwitches:Set(uml::Port):=Set{};
		lcc->forEach(r){
			rightSwitches+=r.ownedElement[uml::Port]->select(x|isStereotypeOrDerivedApplied(x.type, switchSter));
			
		};
		return rightSwitches;
	}
	
	query getMSIAPorts():Set(uml::Port){
	//MSIA ports: 
	//[filter]: generalize MSIA and port of type RS422 and LVDS (input only)
		var msiaPorts:Set(uml::Port)=Set{};
		var msiaLogic:=allLogical->selectOne(x|x.name="MSIA");
		msmPackage![uml::Element]->closure(ownedElement)[uml::Generalization]->select(x|x.general=msiaLogic)->forEach(s){
			s.specific.ownedElement[uml::Port]->forEach(p){
				if(isStereotypeOrDerivedApplied(p.type, rs)=true)then{
					if(p.type.ownedElement[uml::Property]->selectOne(x|isStereotypeOrDerivedApplied(x, flowS)).retrieveFlowProp('in')=true)then msiaPorts+=p endif;
				}endif;
				if(isStereotypeOrDerivedApplied(p.type, lvds)=true)then{
					if(p.type.ownedElement[uml::Property]->selectOne(x|isStereotypeOrDerivedApplied(x, flowS)).retrieveFlowProp('in')=true)then msiaPorts+=p endif;
				}endif;
			};
		};
		return msiaPorts;
	}
	
	query getActuatorPorts():Set(uml::Port){
	//RMCA: RMCR and RMCDs
		var actPorts:Set(uml::Port)=Set{};
		var rmcr:=allRefDes->selectOne(x|x.name="RMCR");
		var rmcd1:=allRefDes->selectOne(x|x.name="RMCD-1");
		var rmcd2:=allRefDes->selectOne(x|x.name="RMCD-2");
		var rmcd3:=allRefDes->selectOne(x|x.name="RMCD-3");
		var rmcd4:=allRefDes->selectOne(x|x.name="RMCD-4");
		var rmcd5:=allRefDes->selectOne(x|x.name="RMCD-5");
		var rmcd6:=allRefDes->selectOne(x|x.name="RMCD-6");
		var rmcd7:=allRefDes->selectOne(x|x.name="RMCD-7");
		var rmcd8:=allRefDes->selectOne(x|x.name="RMCD-8");
		actPorts+=rmcr.ownedElement[uml::Port]->select(x|isStereotypeOrDerivedApplied(x.type, actuator));
		actPorts+=rmcd1.ownedElement[uml::Port]->select(x|isStereotypeOrDerivedApplied(x.type, actuator));
		actPorts+=rmcd2.ownedElement[uml::Port]->select(x|isStereotypeOrDerivedApplied(x.type, actuator));
		actPorts+=rmcd3.ownedElement[uml::Port]->select(x|isStereotypeOrDerivedApplied(x.type, actuator));
		actPorts+=rmcd4.ownedElement[uml::Port]->select(x|isStereotypeOrDerivedApplied(x.type, actuator));
		actPorts+=rmcd5.ownedElement[uml::Port]->select(x|isStereotypeOrDerivedApplied(x.type, actuator));
		actPorts+=rmcd6.ownedElement[uml::Port]->select(x|isStereotypeOrDerivedApplied(x.type, actuator));
		actPorts+=rmcd7.ownedElement[uml::Port]->select(x|isStereotypeOrDerivedApplied(x.type, actuator));
		actPorts+=rmcd8.ownedElement[uml::Port]->select(x|isStereotypeOrDerivedApplied(x.type, actuator));
		
		return actPorts
	}
		
	query getAnalogPorts(in analog:Set(uml::Class)):Set(uml::Port){
	//Analog ports:
	//[filter]Analog: Voltage and Analog:Temp that generalize from REU, TMC, or BCB-1 or BCB-2 (refDes) -->rover only
		var analogPorts:Set(uml::Port)=Set{};
		var bcb1:=allRefDes->selectOne(x|x.name="BCB-1");
		var bcb2:=allRefDes->selectOne(x|x.name="BCB-2");
		var reuA:=allRefDes->selectOne(x|x.name="RREU-A");
		var reuB:=allRefDes->selectOne(x|x.name="RREU-B");
		var tmcA:=allRefDes->selectOne(x|x.name="RTMC-A");
		var tmcB:=allRefDes->selectOne(x|x.name="RTMC-B");
		var bcbBad:Set(String):=Set{'BCB-1-RBAT-1-TEMP','BCB-2-RBAT-2-TEMP','BCB-1-PBC-V-MONS','BCB-2-PBC-V-MONS','BATT-1-CHRG-CURR-TLM','BATT-2-CHRG-CURR-TLM'};
		tmcA.ownedElement[uml::Port]->select(x|isStereotypeOrDerivedApplied(x.type, analogSter))->forEach(p){
			if(p.type.ownedElement[uml::Property]->selectOne(x|isStereotypeOrDerivedApplied(x, flowS)).retrieveFlowProp('in')=true)then analogPorts+=p endif;
		};
		//log('rtmc-A'+analogPorts->size().toString());
		tmcB.ownedElement[uml::Port]->select(x|isStereotypeOrDerivedApplied(x.type, analogSter))->forEach(p){
			if(p.type.ownedElement[uml::Property]->selectOne(x|isStereotypeOrDerivedApplied(x, flowS)).retrieveFlowProp('in')=true)then analogPorts+=p endif;
		};
		//log('rtmc-B'+analogPorts->size().toString());
		bcb1.ownedElement[uml::Port]->select(x|isStereotypeOrDerivedApplied(x.type, analogSter))->forEach(p){
			if(p.type.ownedElement[uml::Property]->selectOne(x|isStereotypeOrDerivedApplied(x, flowS)).retrieveFlowProp('in')=true)then{
				if(bcbBad->select(x|x=p.name)->size()=0) then analogPorts+=p endif;
			}endif;
		};
		//log('bcb1'+analogPorts->size().toString());
		bcb2.ownedElement[uml::Port]->select(x|isStereotypeOrDerivedApplied(x.type, analogSter))->forEach(p){
			if(p.type.ownedElement[uml::Property]->selectOne(x|isStereotypeOrDerivedApplied(x, flowS)).retrieveFlowProp('in')=true)then{
				if(bcbBad->select(x|x=p.name)->size()=0)then analogPorts+=p endif;
			}endif;
		};
		//log('bcb2'+analogPorts->size().toString());
		reuA.ownedElement[uml::Port]->select(x|isStereotypeOrDerivedApplied(x.type, analogSter))->forEach(p){
			if(p.type.ownedElement[uml::Property]->selectOne(x|isStereotypeOrDerivedApplied(x, flowS)).retrieveFlowProp('in')=true)then analogPorts+=p endif;
		};
		//log('tmcA'+analogPorts->size().toString());
		reuB.ownedElement[uml::Port]->select(x|isStereotypeOrDerivedApplied(x.type, analogSter))->forEach(p){
			if(p.type.ownedElement[uml::Property]->selectOne(x|isStereotypeOrDerivedApplied(x, flowS)).retrieveFlowProp('in')=true)then analogPorts+=p endif;
		
		};
		//log('tmcB'+analogPorts->size().toString());
		
		return analogPorts;
	}
	
	query uml::Type::retrieveText(in wantedValue:String, in prop:uml::Property):Boolean{
		var feature := self.appliedStereotypeInstance.slot->selectOne(i|i.definingFeature=prop).ownedElement[uml::LiteralString];
		//log(feature);
		if(feature->size()=0)then{
			return null;
		}else{
			if(feature.value->collectOne(i|i)![String]=wantedValue)then{
				return true;
			}else{
				return false;
			}endif;
		}endif;
	}
	
	query uml::Property::retrieveFlowProp(in value:String):Boolean{
		var enumerationValue:=flowDirection.type![uml::Enumeration].ownedLiteral->selectOne(i|i.name=value);
		var flow := self.appliedStereotypeInstance.slot->selectOne(i|i.definingFeature=flowDirection).value[uml::InstanceValue].instance[uml::EnumerationLiteral];
		if(flow->collectOne(i|i)=enumerationValue) then{
			return true;
		}else{
			return false;
		}endif;
	}
}

